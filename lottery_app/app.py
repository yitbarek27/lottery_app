from flask import Flask, render_template, request, redirect, url_for, flash, session, jsonify
import sqlite3
from datetime import datetime
import os
import secrets
import requests  # For SMS API

app = Flask(__name__)
app.secret_key = 'supersecretkey_for_session_management_and_flash_messages'
app.config['ORGANIZATION_NAME'] = "·àõ·àÖ·â†·à® ·ä†·à≠·åã·â•"
DB_NAME = 'lottery.db'
ADMIN_USERNAME = 'admin'
ADMIN_PASSWORD = 'password123'

# SMS Configuration (Example using Ethio Telecom SMS Gateway)
SMS_API_URL = "https://sms.example.com/api/send"  # Replace with actual SMS gateway URL
SMS_API_KEY = "your_sms_api_key"
TELEBIRR_OWNER = "+251936114505"

# Database setup
def init_db():
    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()
    
    # Drop existing table and recreate with new schema
    cur.execute('DROP TABLE IF EXISTS applications')
    
    cur.execute('''
    CREATE TABLE IF NOT EXISTS applications (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        full_name TEXT NOT NULL,
        phone TEXT NOT NULL,
        draw INTEGER NOT NULL UNIQUE,  -- UNIQUE constraint ensures one ticket per draw
        confirmation_code TEXT NOT NULL UNIQUE,
        payment_method TEXT NOT NULL,
        transaction_id TEXT,
        transaction_validated BOOLEAN DEFAULT FALSE,
        status TEXT DEFAULT 'pending',
        ticket_price INTEGER DEFAULT 10,  -- Ticket price in ETB
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    conn.commit()
    conn.close()

init_db()

# Utility Functions
def generate_confirmation_code():
    return secrets.token_urlsafe(8).upper()

def send_sms(phone_number, message):
    """
    Send SMS to user - Integrate with actual SMS gateway
    """
    try:
        # Example SMS integration (replace with actual SMS gateway)
        payload = {
            'api_key': SMS_API_KEY,
            'to': phone_number,
            'message': message,
            'sender': 'LottoWin'
        }
        
        # Uncomment to actually send SMS
        # response = requests.post(SMS_API_URL, json=payload)
        # return response.status_code == 200
        
        # For demo purposes, just print the SMS
        print(f"üì± SMS to {phone_number}: {message}")
        return True
        
    except Exception as e:
        print(f"SMS sending failed: {e}")
        return False

# Context Processor
@app.context_processor
def inject_global_data():
    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()
    
    # Get available draws (not taken yet)
    cur.execute("SELECT draw FROM applications WHERE status != 'cancelled'")
    taken_draws = [row[0] for row in cur.fetchall()]
    available_draws = [i for i in range(1, 301) if i not in taken_draws]
    
    draws_data = [{'id': i, 'name': f"·ãï·å£ ·âÅ·å•·à≠ {i}"} for i in available_draws]
    conn.close()
    
    return {
        'current_year': datetime.utcnow().year,
        'organization_name': app.config['ORGANIZATION_NAME'],
        'draws_data': draws_data,
        'ticket_price': 10  # 10 ETB
    }

# Routes
@app.route('/')
def home():
    return render_template('index.html')

@app.route('/apply', methods=['GET', 'POST'])
def apply():
    if request.method == 'POST':
        full_name = request.form['full_name']
        phone = request.form['phone']
        draw = request.form['draw']
        payment_method = request.form['payment_method']
        transaction_id = request.form.get('transaction_id')
        confirmation_code = generate_confirmation_code()

        conn = sqlite3.connect(DB_NAME)
        cur = conn.cursor()
        
        try:
            # Check if draw number is already taken
            cur.execute("SELECT id FROM applications WHERE draw = ?", (draw,))
            if cur.fetchone():
                flash("·ã≠·àÖ ·ã®·ãï·å£ ·âÅ·å•·à≠ ·ä†·àµ·âÄ·ãµ·àû ·â∞·ã≠·ãü·àç·ç¢ ·ä•·â£·ä≠·ãé ·àå·àã ·âÅ·å•·à≠ ·ã≠·àù·à®·å°·ç¢", 'error')
                return redirect(url_for('apply'))

            cur.execute(
                "INSERT INTO applications (full_name, phone, draw, confirmation_code, payment_method, transaction_id, ticket_price) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (full_name, phone, draw, confirmation_code, payment_method, transaction_id, 10)
            )
            conn.commit()
            application_id = cur.lastrowid

            # Send SMS confirmation
            sms_message = f"·ã®·ãï·å£ ·âµ·ä¨·âµ ·å•·ã´·âÑ·ãé ·â∞·âÄ·â•·àà·äì·àç·ç¢ ·ã®·àõ·à®·åã·åà·å´ ·äÆ·ãµ·ãé: {confirmation_code}·ç¢ ·ãï·å£: {draw}·ç¢ ·ãã·åã: 10 ·â•·à≠·ç¢"
            send_sms(phone, sms_message)

            application_data = {
                'id': application_id,
                'full_name': full_name,
                'phone': phone,
                'draw': draw,
                'confirmation_code': confirmation_code,
                'payment_method': payment_method,
                'ticket_price': 10
            }
            return render_template('confirmation.html', application=application_data)

        except sqlite3.IntegrityError as e:
            if 'UNIQUE constraint failed: applications.draw' in str(e):
                flash("·ã≠·àÖ ·ã®·ãï·å£ ·âÅ·å•·à≠ ·ä†·àµ·âÄ·ãµ·àû ·â∞·ã≠·ãü·àç·ç¢ ·ä•·â£·ä≠·ãé ·àå·àã ·âÅ·å•·à≠ ·ã≠·àù·à®·å°·ç¢", 'error')
            else:
                flash("·àµ·àÖ·â∞·âµ: ·â∞·àò·à≥·à≥·ã≠ ·ã®·àõ·à®·åã·åà·å´ ·äÆ·ãµ ·ä†·àµ·âÄ·ãµ·àû ·ä†·àà·ç¢ ·ä•·â£·ä≠·ãé ·ä•·äï·ã∞·åà·äì ·ã≠·àû·ä≠·à©·ç¢", 'error')
            return redirect(url_for('apply'))
        finally:
            conn.close()
    
    return render_template('apply.html')

@app.route('/payment-instructions')
def payment_instructions():
    return render_template('payment_instructions.html')

@app.route('/admin-login', methods=['GET', 'POST'])
def admin_login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        if username == ADMIN_USERNAME and password == ADMIN_PASSWORD:
            session['admin_logged_in'] = True
            flash('·ä•·äï·ä≥·äï ·ã∞·àÖ·äì ·àò·å° ·ä†·àµ·â∞·ã≥·ã≥·à™!', 'success')
            return redirect(url_for('admin_panel'))
        else:
            flash('·âµ·ä≠·ä≠·àç ·ã´·àç·àÜ·äê ·ã®·â∞·å†·âÉ·àö ·àµ·àù ·ãà·ã≠·àù ·ã®·ã≠·àà·çç ·âÉ·àç', 'error')
    return render_template('admin_login.html')

@app.route('/admin-logout')
def admin_logout():
    session.pop('admin_logged_in', None)
    flash('·â†·â∞·à≥·ä´ ·àÅ·äî·â≥ ·ãà·å•·â∞·ãã·àç', 'info')
    return redirect(url_for('admin_login'))

@app.route('/admin')
def admin_panel():
    if not session.get('admin_logged_in'):
        return redirect(url_for('admin_login'))

    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()
    cur.execute("SELECT id, full_name, phone, draw, confirmation_code, payment_method, transaction_id, transaction_validated, status, ticket_price, created_at FROM applications ORDER BY created_at DESC")
    
    applications = []
    for row in cur.fetchall():
        app_data = {
            'id': row[0],
            'full_name': row[1],
            'phone': row[2],
            'draw': row[3],
            'confirmation_code': row[4],
            'payment_method': row[5],
            'transaction_id': row[6],
            'transaction_validated': row[7],
            'status': row[8],
            'ticket_price': row[9],
            'created_at': row[10]
        }
        applications.append(app_data)
    
    conn.close()
    return render_template('admin_panel.html', applications=applications)

@app.route('/verify-payment/<int:app_id>')
def verify_payment(app_id):
    if not session.get('admin_logged_in'):
        return redirect(url_for('admin_login'))

    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()
    
    # Get application details
    cur.execute("SELECT phone, draw FROM applications WHERE id = ?", (app_id,))
    app_data = cur.fetchone()
    
    if app_data:
        phone, draw = app_data
        # Send SMS notification
        sms_message = f"·ä≠·çç·ã´·ãé ·â∞·à®·åã·åç·åß·àç! ·ãï·å£ ·âÅ·å•·à≠: {draw}·ç¢ ·ã®·ãï·å£ ·ãç·å§·âµ ·â†·àö·åà·äù ·åä·ãú ·ã≠·å†·â†·âÉ·àç·ç¢"
        send_sms(phone, sms_message)
    
    cur.execute("UPDATE applications SET status = 'verified' WHERE id = ?", (app_id,))
    conn.commit()
    conn.close()
    
    flash(f'Application {app_id} marked as Verified! SMS sent to user.', 'success')
    return redirect(url_for('admin_panel'))

@app.route('/mark-paid/<int:app_id>')
def mark_paid(app_id):
    if not session.get('admin_logged_in'):
        return redirect(url_for('admin_login'))

    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()
    
    # Get application details
    cur.execute("SELECT phone, draw FROM applications WHERE id = ?", (app_id,))
    app_data = cur.fetchone()
    
    if app_data:
        phone, draw = app_data
        # Send SMS notification
        sms_message = f"·âµ·ä¨·âµ·ãé ·â∞·àû·àç·â∑·àç! ·ãï·å£ ·âÅ·å•·à≠: {draw}·ç¢ ·ã®·ãï·å£ ·ãç·å§·âµ ·â†·àö·åà·äù ·åä·ãú ·ã≠·å†·â†·âÉ·àç·ç¢"
        send_sms(phone, sms_message)
    
    cur.execute("UPDATE applications SET status = 'paid' WHERE id = ?", (app_id,))
    conn.commit()
    conn.close()
    
    flash(f'Application {app_id} marked as Paid (Ticket Filled)! SMS sent to user.', 'success')
    return redirect(url_for('admin_panel'))

@app.route('/validate-transaction', methods=['POST'])
def validate_transaction_api():
    if not session.get('admin_logged_in'):
        return jsonify({"valid": False, "message": "Unauthorized"}), 401

    data = request.json
    transaction_id = data.get('transaction_id', '').upper()
    payment_method = data.get('payment_method')

    # Simulate transaction validation
    is_valid = False
    message = "·âµ·à´·äï·ãõ·ä≠·àΩ·äï ·âÅ·å•·à≠ ·ä†·àç·â∞·åà·äò·àù ·ãà·ã≠·àù ·âµ·ä≠·ä≠·àç ·ä†·ã≠·ã∞·àà·àù·ç¢"
    suggestions = []

    if payment_method == 'telebirr':
        if transaction_id.startswith('TBR') and len(transaction_id) >= 10 and transaction_id != 'TBR123456789':
            is_valid = True
            message = "·ã®TeleBirr ·âµ·à´·äï·ãõ·ä≠·àΩ·äï ·âÅ·å•·à≠ ·âµ·ä≠·ä≠·àç ·äê·ãç!"
        else:
            suggestions.append("·ã®TeleBirr ·âµ·à´·äï·ãõ·ä≠·àΩ·äï ·âÅ·å•·àÆ·âΩ ·ä†·â•·ãõ·äõ·ãç·äï ·åä·ãú ·â† 'TBR' ·ã≠·åÄ·àù·à´·àâ·ç¢")
    elif payment_method == 'cbe_mobile':
        if transaction_id.startswith('CBE') and len(transaction_id) >= 10 and transaction_id != 'CBE123456789':
            is_valid = True
            message = "·ã®CBE Mobile ·âµ·à´·äï·ãõ·ä≠·àΩ·äï ·âÅ·å•·à≠ ·âµ·ä≠·ä≠·àç ·äê·ãç!"
        else:
            suggestions.append("·ã®CBE Mobile ·âµ·à´·äï·ãõ·ä≠·àΩ·äï ·âÅ·å•·àÆ·âΩ ·ä†·â•·ãõ·äõ·ãç·äï ·åä·ãú ·â† 'CBE' ·ã≠·åÄ·àù·à´·àâ·ç¢")

    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()
    
    if is_valid:
        cur.execute("SELECT id FROM applications WHERE transaction_id = ? AND transaction_validated = TRUE", (transaction_id,))
        if cur.fetchone():
            is_valid = False
            message = "·ã≠·àÖ ·âµ·à´·äï·ãõ·ä≠·àΩ·äï ·âÅ·å•·à≠ ·ä†·àµ·âÄ·ãµ·àû ·â∞·à®·åã·åç·å¶ ·å•·âÖ·àù ·àã·ã≠ ·ãç·àè·àç·ç¢"
            suggestions = ["·ä†·ã≤·àµ ·âµ·à´·äï·ãõ·ä≠·àΩ·äï ·âÅ·å•·à≠ ·ã´·àµ·åà·â°·ç¢"]
        else:
            cur.execute("UPDATE applications SET transaction_validated = TRUE WHERE transaction_id = ?", (transaction_id,))
            conn.commit()
            if cur.rowcount == 0:
                is_valid = False
                message = "·âµ·à´·äï·ãõ·ä≠·àΩ·äï ·âÅ·å•·à© ·âµ·ä≠·ä≠·àç ·â¢·àÜ·äï·àù ·â†·àù·äï·àù ·å•·ã´·âÑ ·àã·ã≠ ·ä†·àç·â∞·åà·äò·àù·ç¢"
                suggestions = ["·âµ·à´·äï·ãõ·ä≠·àΩ·äï ·âÅ·å•·à©·äï ·â†·âµ·ä¨·âµ ·å•·ã´·âÑ ·âÖ·åΩ ·àã·ã≠ ·àò·àô·àã·âµ·ãé·äï ·ã´·à®·åã·åç·å°·ç¢"]

    conn.close()
    return jsonify({"valid": is_valid, "message": message, "suggestions": suggestions})

@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

if __name__ == '__main__':
    app.run(debug=True)